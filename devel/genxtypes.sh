#!/bin/sh
# $Id; genxtypes.sh $
# -*- coding: utf-8 -*-
#
# Author: Tomi Ollila -- too Ã¤t iki piste fi
#
#	Copyright (c) 2007 Tomi Ollila
#	    All rights reserved
#
# Created: Tue Mar 27 17:23:11 EEST 2007 too
# Last modified: Sat Jan 05 21:33:08 EET 2008 too

# This script uses c compiler generated object files to figure
# out variable type sizes and machine endianess.
# C99 stdint.h could be used to figure out sizes of variable types
# but there is no (as far as I know) common way to figure out
# whether machine architecture is BIG ENDIAN or LITTLE ENDIAN.
#
# So, as we need to figure out endianess, why not figure out type
# sizes at the same time. C99 is nice, but not universally taken
# in use, yet.
#
# To examine generated object coded instead just creating and running
# program allows this to be used in cross-compiling environment.

# This particular script (genxtypes.sh) is public domain, use it as you wish.
# Standard disclaimers apply, no WARRANTY and such.

e2 () { echo "$@" >&2; }
ee () { e2 "$@"; exit 1; }

case $1 in '') ee Usage $0 '<cc-command>';; esac

exec > xtypes_h.tmp

deltemps () { rm -f _test _test.c; }
deltemps2 () { deltemps; rm -f xtypes_h.tmp; }
trap deltemps2 0

deltemps
cat > _test.c <<EOF
#define prefix 0x767676, 0x616161, 0x6c6c6c, 0x20
long la[] = { 0x0a,
    prefix, (long)'c', 0x3d, sizeof (char) + 0x30, 0x0a,
    prefix, (long)'s', 0x3d, sizeof (short) + 0x30, 0x0a,
    prefix, (long)'i', 0x3d, sizeof (int) + 0x30, 0x0a,
    prefix, (long)'l', 0x3d, sizeof (long) + 0x30, 0x0a,
    prefix, (long)'L', 0x3d, sizeof (long long) + 0x30, 0x0a,
    prefix, (long)'p', 0x3d, sizeof (void*) + 0x30, 0x0a,
};
EOF

"$@" -c -o _test _test.c
ts_c= ts_s= ts_i= ts_l= ts_L= ts_p=
eval `tr -d '\000' < _test | strings | awk '/^vvvaaalll/{ print "ts_" $2 $3 }'`

case $ts_c in 1) ;; *) ee Need to have sizeof '(char)' == 1;; esac

matchsize ()
{
    case $1 in
	$ts_i) echo int ;;
	$ts_l) echo long ;;
	$ts_L) echo long long ;;
	$ts_s) echo short ;;
    esac
}

int16var=`matchsize 2`
int32var=`matchsize 4`
int64var=`matchsize 8`
intptrvar=`matchsize $ts_p`

case $int16var in '') ee Required 16 bit integer type not found ;; esac
case $int32var in '') ee Required 32 bit integer type not found ;; esac
case $int64var in '') ee Required 64 bit integer type not found ;; esac
case $intptrvar in '') ee Required pointer sized integer type not found ;; esac

deltemps

cat > _test.c <<EOF
$int32var ia[] = { 0x0a,
    0x626262, 0x797979, 0x6f6f6f, 0x727272, 0x20, 0x34333231, 0x0a };
EOF
#cat _test.c >&2
"$@" -c -o _test _test.c
eval `tr -d '\000' < _test | strings | awk '/^bbbyyyooorrr/{ print "bo=" $2 }'`

case $bo in 1234|4321) ;; *) ee Byte order \"$bo\" not 1234 or 4321 ;; esac

cat <<EOF
/*
 * Generated by $0. Do not edit!
 */

/* Include this *after* system includes */

#ifndef XTYPES_H
#define XTYPES_H

#undef __BYTE_ORDER
#define __BYTE_ORDER    $bo
#undef __LITTLE_ENDIAN
#define __LITTLE_ENDIAN 1234
#undef __BIG_ENDIAN
#define __BIG_ENDIAN    4321

/* Exact integral types */

typedef char  int8_t;
typedef unsigned char  uint8_t;

typedef $int16var  int16_t;
typedef unsigned $int16var  uint16_t;

typedef $int32var  int32_t;
typedef unsigned $int32var uint32_t;

typedef $int64var  int64_t;
typedef unsigned $int64var  uint64_t;

/* Types for 'void *' pointers. */

typedef $intptrvar  intptr_t;
typedef unsigned $intptrvar  uintptr_t;

#endif /* XTYPES_H */

EOF

rm -f xtypes.h
mv xtypes_h.tmp xtypes.h
